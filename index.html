<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="/favicon.ico">
  <meta charset="UTF-8">
  <title>Annotator</title>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.4.0/fabric.min.js"></script>
  <style>
        #container { position: relative; }
        #container canvas, #overlay { position: absolute; }
        canvas { border: 1px solid black; }
  </style>
</head>
<body>
<div>
  <button id="prev">Previous</button>
  <button id="next">Next</button>
  &nbsp; &nbsp;
  <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
</div>
<div id="container">
  <canvas id="pdfcanvas"></canvas>
  <canvas id="overlay"></canvas>
</div>

<div>
        <br/>
</div>


<script> 
  // PDF
  //
  // If absolute URL from the remote server is provided, configure the CORS
  // header on that server.
  //
  var url = './dataset/testfile.pdf';

  //
  // The workerSrc property shall be specified.
  //
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.js';

  var pdfDoc = null,
      pageNum = 1,
      pageRendering = false,
      pageNumPending = null,
      scale = 1,
      canvas = document.getElementById('pdfcanvas'),
      ctx = canvas.getContext('2d'),
      overlay = document.getElementById('overlay'),
      overlayctx = overlay.getContext('2d'),
      shapes = [],
      isDragging=false,
      selectedShapeIndex=false,
      x, y, dx, dy, newX, newY, offsetX, offsetY;

  /**
   * Get page info from document, resize canvas accordingly, and render page.
   * @param num Page number.
   */
  function renderPage(num) {
    pageRendering = true;
    // Using promise to fetch the page
    pdfDoc.getPage(num).then(function(page) {
      var viewport = page.getViewport({scale: scale});
      canvas.height = viewport.height;
      canvas.width = viewport.width;

      // Render PDF page into canvas context
      var renderContext = {
        canvasContext: ctx,
        viewport: viewport
      };
      var renderTask = page.render(renderContext);

      // Wait for rendering to finish
      renderTask.promise.then(function() {
        pageRendering = false;
        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pageNumPending);
          pageNumPending = null;
        }
      loadJson('./dataset/testfile.json');
      annotate(pageNum);
      });
    });

    // Update page counters
    document.getElementById('page_num').textContent = num;
  }

  /**
   * If another page rendering in progress, waits until the rendering is
   * finised. Otherwise, executes rendering immediately.
   */
  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPage(num);
    }
  }

  /**
   * Displays previous page.
   */
  function onPrevPage() {
    if (pageNum <= 1) {
      return;
    }
    pageNum--;
    selectedShapeIndex=false;
    queueRenderPage(pageNum);
  }
  document.getElementById('prev').addEventListener('click', onPrevPage);

  /**
   * Displays next page.
   */
  function onNextPage() {
    if (pageNum >= pdfDoc.numPages) {
      return;
    }
    pageNum++;
    selectedShapeIndex=false;
    queueRenderPage(pageNum);
  }
  document.getElementById('next').addEventListener('click', onNextPage);

  function loadJson(url) {
    // get shapes from Google Vision generated json
    fetch(url)
    .then(response => response.json())
    .then(response => { 
        for (var i=0; i<response.responses.length; i++) {
          shapes[i] = [];
          var blocks = response.responses[i].fullTextAnnotation.pages[0].blocks;
          var marge = 5;
          for (var j=0; j < blocks.length; j++) {
                var coords = blocks[j].boundingBox.normalizedVertices;
                // convert normalizedVertices to regular coords
                coords = coords.map(function(element) { return [element.x * overlay.width, 
                                                                element.y * overlay.height] });
                x = coords[0][0] - marge;
                y = coords[0][1] - marge;
                dx = coords[2][0] - coords[0][0] + marge*2;
                dy = coords[2][1] - coords[0][1] + marge*2;
                shapes[i].push({x, y, dx , dy});
          }
        }
    });
  }

  function annotate(num) {
    // Annotator
    // https://riptutorial.com/html5-canvas/example/18918/dragging-circles---rectangles-around-the-canvas

    refreshOverlay = setInterval(drawAll, 500);
    overlay.width = canvas.width;
    overlay.height = canvas.height;
    // used to calc canvas position relative to window
    function reOffset() {
      var BB = overlay.getBoundingClientRect();
      offsetX = BB.left;
      offsetY = BB.top;        
    };
    reOffset();
    window.onscroll = function(e){ reOffset(); }
    window.onresize = function(e){ reOffset(); }
    canvas.onresize = function(e){ reOffset(); }

    // clear the canvas and 
    // redraw all shapes in their current positions every 10ms
    function drawAll() {
      //console.log(canvas.width, canvas.height);  
      overlayctx.clearRect(0, 0, overlay.width, overlay.height)
      for (var i=0; i<shapes[pageNum-1].length; i++) {
        shape = shapes[pageNum-1][i]
        overlayctx.lineWidth = 1
        if(i == selectedShapeIndex) { overlayctx.lineWidth = 2 }
        overlayctx.strokeRect(shape.x, shape.y, shape.dx, shape.dy)
        }
    };

    overlay.addEventListener('mousedown', e => {
      selectedShapeIndex = false
      clearInterval(refreshOverlay)
      isDragging = true
      // calculate the current mouse position
      x = parseInt(e.clientX - offsetX)
      y = parseInt(e.clientY - offsetY)
      
      // if mouse is in a shape, select it
      for (var i=0; i<shapes[pageNum-1].length; i++) {
        shape = shapes[pageNum-1][i]
        if(x>shape.x && x<shape.x+shape.dx && y>shape.y && y<shape.y+shape.dy) {
          selectedShapeIndex = i
          //console.log(selectedShapeIndex)
        }
      }
    });

    overlay.addEventListener('mousemove', e => {
      // return if we're not dragging
      //console.log(isDragging)
      //console.log(selectedShapeIndex)
      if(!isDragging){return}
      newX = parseInt(e.clientX - offsetX)
      newY = parseInt(e.clientY - offsetY)
      dx = newX - x
      dy = newY - y
      if(!Number.isInteger(selectedShapeIndex)) {
        // draw a new rectangle
        drawAll()
        overlayctx.strokeRect(x, y, dx, dy)
      }
      
    });
        
    overlay.addEventListener('mouseup', e => {
      // the drag is over -- clear the isDragging flag
      isDragging = false
      refreshOverlay = setInterval(drawAll, 100)
      // how far has the mouse dragged from its previous mousemove position?
      newX = parseInt(e.clientX - offsetX)
      newY = parseInt(e.clientY - offsetY)
      dx = newX - x
      dy = newY - y
      if (dx == 0 || dy == 0) {return}

      if(Number.isInteger(selectedShapeIndex)) {
        shape = shapes[pageNum-1][selectedShapeIndex]
        shape.x += dx
        shape.y += dy
        }
      else 
      {
        shapes[pageNum-1].push({x, y, dx, dy})
        selectedShapeIndex = shapes[pageNum-1].length
      }
    });

    overlay.addEventListener('mouseout', e => {
      // return if we're not dragging
      if(!isDragging){return}
      // the drag is over -- clear the isDragging flag
      isDragging = false
      //selectedShapeIndex = false;
    });

    document.addEventListener('keydown', e => {
      e.preventDefault();
      if (["Backspace", "Delete", "x"].includes(e.key)) {
        shapes[pageNum-1].splice(selectedShapeIndex, 1);
        drawAll();
      }
    });
  }


  /**
   * Asynchronously downloads PDF.
   */
  pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
    pdfDoc = pdfDoc_
    document.getElementById('page_count').textContent = pdfDoc.numPages
    // Initial/first page rendering
    renderPage(pageNum)
  });



</script>

</body>
</html>
