<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="/favicon.ico">
  <meta charset="UTF-8">
  <title>Annotator</title>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>
  <style>
        #container { position: relative; }
        #container canvas, #overlay { position: absolute; }
        canvas { border: 1px solid black; }
  </style>

</head>
<body>

<div id="container">
  <canvas id="pdfcanvas"></canvas>
  <canvas id="overlay"></canvas>
</div>

<div>
        <br/>
</div>


<script> 
  // PDF
  //
  // If absolute URL from the remote server is provided, configure the CORS
  // header on that server.
  //
  var url = './dataset/testfile.pdf';
  var pagenum = 6;

  //
  // The workerSrc property shall be specified.
  //
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.js';

  //
  // Asynchronous download PDF
  //
  var loadingTask = pdfjsLib.getDocument(url);
  loadingTask.promise.then(function(pdf) {
    //
    // Fetch the first page
    //
    pdf.getPage(pagenum).then(function(page) {
      var scale = .9;
      var viewport = page.getViewport({ scale: scale, });

      //
      // Prepare canvas using PDF page dimensions
      //
      var canvas = document.getElementById('pdfcanvas');
      var context = canvas.getContext('2d');
      canvas.width = viewport.width;
      canvas.height = viewport.height;

      //
      // Render PDF page into canvas context
      //
      var renderContext = {
        canvasContext: context,
        viewport: viewport,
      };
      //context.fillStyle = 'rgb(255, 0, 0)';
      //context.fillRect(50, 50, 100, 150);
      page.render(renderContext);


    // Annotator
    // https://riptutorial.com/html5-canvas/example/18918/dragging-circles---rectangles-around-the-canvas
      var canvas = document.getElementById('overlay');
      var pdfcanvas = document.getElementById('pdfcanvas');
      canvas.width = pdfcanvas.width;
      canvas.height = pdfcanvas.height;
      var context = canvas.getContext('2d');
      var url = './dataset/testfile.json';

      // save relevant information about shapes drawn on the canvas
      var shapes = [], deletekeys = [46, 8];

      // drag related vars
      var isDragging=false, handlesSize=8, currentHandle=false, selectedShape=0, selectedShapeIndex=false;
      var startX, startY;

      // redraw overlay shape every 5ms
      var refreshOverlay = setInterval(drawAll, 10);

      // used to calc canvas position relative to window
      function reOffset() {
        var BB = canvas.getBoundingClientRect();
        offsetX = BB.left;
        offsetY = BB.top;        
      };
      var offsetX, offsetY;
      reOffset();
      window.onscroll = function(e){ reOffset(); }
      window.onresize = function(e){ reOffset(); }
      canvas.onresize = function(e){ reOffset(); }

      // given mouse X & Y (mx & my) and shape object
      // return true/false whether mouse is inside the shape
      function isMouseInShape(mx, my, shape) {
          var rLeft = shape.startX;
          var rRight = shape.startX + shape.dx;
          var rTop = shape.startY;
          var rBott = shape.startY + shape.dy;
          // math test to see if mouse is inside rectangle
          if( mx>rLeft && mx<rRight && my>rTop && my<rBott){
              return(true);
          }
        // the mouse isn't in any of the shapes
        return(false);
      };

      // clear the canvas and 
      // redraw all shapes in their current positions
      function drawAll() {
        //console.log(canvas.width, canvas.height);  
        context.clearRect(0, 0, canvas.width, canvas.height);
        for(var i=0; i<shapes.length; i++) {
            var shape = shapes[i];
            if (shape == selectedShape) {context.lineWidth = 2 } else {context.lineWidth = 1};
            context.strokeRect(shape.startX, shape.startY, shape.dx, shape.dy);
            }
      };

      // distance from a corner
      function dist(x1,y1,x2,y2) { 
        if(!x2) x2=0; 
        if(!y2) y2=0;
        return Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1)); 
      };

      // get shapes from Google Vision generated json
      fetch(url)
      .then(response => response.json())
      .then(response => { 
          var blocks = response.responses[pagenum-1].fullTextAnnotation.pages[0].blocks;
          var marge = 5;
          for (var i=0; i < blocks.length; i++) {
                  var coords = blocks[i].boundingBox.normalizedVertices;
                  // convert normalizedVertices to regular coords
                  coords = coords.map(function(element) { return [element.x * canvas.width, 
                                                                  element.y * canvas.height] });
                  startX = coords[0][0] - marge;
                  startY = coords[0][1] - marge;
                  dx = coords[2][0] - coords[0][0] + marge*2;
                  dy = coords[2][1] - coords[0][1] + marge*2;
                  shapes.push({startX, startY, dx , dy});
          }
      })
      .catch(error => console.log("Erreur : " + error));



      canvas.addEventListener('mousedown', e => {
          selectedShapeIndex = false;
          clearInterval(refreshOverlay);
          isDragging = true;
          // calculate the current mouse position
          startX = parseInt(e.clientX - offsetX);
          startY = parseInt(e.clientY - offsetY);
          // test mouse position against all shapes
          // post result if mouse is in a shape
          for (var i=0; i < shapes.length; i++) {
              if(isMouseInShape(startX, startY, shapes[i])) {
                  // the mouse is inside this shape
                  // select this shape
                  selectedShapeIndex = i;
                  selectedShape = shapes[selectedShapeIndex];
                  console.log(dist(selectedShape.startX, selectedShape.startY, startX, startY))
              }
          }
      });

      canvas.addEventListener('mouseout', e => {
          // return if we're not dragging
          if(!isDragging){return;}
          // the drag is over -- clear the isDragging flag
          isDragging = false;
          selectedShapeIndex = false;
      });

      canvas.addEventListener('mousemove', e => {
          // return if we're not dragging
          if(!isDragging){
            return;
          }

          // calculate the current mouse position         
          mouseX = parseInt(e.clientX - offsetX);
          mouseY = parseInt(e.clientY - offsetY);
          // how far has the mouse dragged from its previous mousemove position?
          var dx = mouseX - startX;
          var dy = mouseY - startY;
          if(Number.isInteger(selectedShapeIndex)) {
              // move the selected shape by the drag distance
              selectedShape = shapes[selectedShapeIndex];
          } else {
              drawAll();
              context.strokeRect(startX, startY, dx, dy);
          }
      });
          
      canvas.addEventListener('mouseup', e => {
          refreshOverlay = setInterval(drawAll, 10);
          // return if we're not dragging
          if(!isDragging){return;}
          // calculate the current mouse position         
          mouseX = parseInt(e.clientX - offsetX);
          mouseY = parseInt(e.clientY - offsetY);
          // how far has the mouse dragged from its previous mousemove position?
          var dx = mouseX - startX;
          var dy = mouseY - startY;
          // the drag is over -- clear the isDragging flag
          isDragging = false;
          if(Number.isInteger(selectedShapeIndex)) {
              // move the selected shape by the drag distance
              selectedShape = shapes[selectedShapeIndex];
              selectedShape.startX += dx;
              selectedShape.startY += dy;
              drawAll();
              //selectedShapeIndex = false;
          } else {
              drawAll();
              context.strokeRect(startX, startY, dx, dy);
              shapes.push({startX, startY, dx , dy});
          }
      });

      document.addEventListener('keydown', ({key}) => {
        console.log(key);
        console.log(selectedShapeIndex);
        console.log(selectedShape);
        if (["Backspace", "Delete", "x"].includes(key)) {
          shapes.splice(selectedShapeIndex, 1);
          drawAll();
        }
      });


    });
  });


</script>

</body>
</html>
