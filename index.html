<!DOCTYPE html>
<html>
<head>
  <link rel="icon" href="/favicon.ico">
  <meta charset="UTF-8">
  <title>Annotator</title>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.min.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/3.4.0/fabric.min.js"></script>
  <style>
        #container { position: relative }
        #container canvas, #overlay { position: absolute}
        canvas { border: 1px solid black }
        .flex-container { display: flex; flex-direction: row;  align-content: space-between;}
        .sidebar {flex: 1; height:100vh; position:absolute; top:0px; left: 5px;}
        .content {flex: 1; height:100vh; position:absolute; top:0px; left: 15%;}
        ul, li { padding: 10px 15px 18px 15px;  list-style-type: none;}
  </style>
</head>
<body>
  <div class="flex-container">

    <div class="sidebar">
      <br/>
      <ul>
        <li class="annotator" style="background-color: #2678B2">Titre</li>
        <li class="annotator" style="background-color: #AFC8E7">Sous-titre</li>
        <li class="annotator" style="background-color: #FD7F28">Paragraphe</li>
        <li class="annotator" style="background-color: #FDBA7D">Auteur</li>
        <li class="annotator" style="background-color: #339F34">Citation</li>
        <li class="annotator" style="background-color: #FDEA7E">Référence</li>
        <li class="annotator" style="background-color: #9ADE8D">Image</li>
        <li class="annotator" style="background-color: #D83F44">Légende</li>
        <li class="annotator" style="background-color: #FD9998">Encadré</li>
        <li class="annotator" style="background-color: #936ABB">Tableau</li>
        <li class="annotator" style="background-color: #C5B1D4">Copyright</li>
        <li class="annotator" style="background-color: #E17AC1">Pied de page</li>
        <li class="annotator" style="background-color: #BCBC35">Numéro de page</li>
      </ul>
    </div>

    <div> &nbsp;  &nbsp;</div>

    <div class="content">
      <div>
        <button id="prev">Previous</button>
        <button id="next">Next</button>
        <span>Page: <span id="page_num"></span> / <span id="page_count"></span></span>
      </div>
      <div id="container">
        <canvas id="pdfcanvas"></canvas>
        <canvas id="overlay"></canvas>
      </div>
    </div>
    
  </div>


<script> 
  // PDF
  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.5.207/pdf.worker.js';

  var url = './dataset/MachineLearningForDummies_extract.pdf',
      jsonfile = './dataset/MachineLearningForDummies_extract.json',
      pdfDoc = null,
      pageNum = 1,
      pageRendering = false,
      pageNumPending = null,
      scale = 1,
      canvas = document.getElementById('pdfcanvas'),
      ctx = canvas.getContext('2d'),
      overlay = document.getElementById('overlay'),
      overlayctx = overlay.getContext('2d'),
      shapes = [],
      isDragging=false,
      selectedShapeIndex=false,
      jsonloaded=false,
      color='black',
      x, y, dx, dy, newX, newY, 
      offsetX, offsetY, cornerX, cornerY;

  /**
   * Get page info from document, resize canvas accordingly, and render page.
   * @param num Page number.
   */
  function renderPage(num) {
    pageRendering = true;
    // Using promise to fetch the page
    pdfDoc.getPage(num).then(function(page) {
      var viewport = page.getViewport({scale: scale});
      canvas.height = viewport.height;
      canvas.width = viewport.width;

      // Render PDF page into canvas context
      var renderContext = {
        canvasContext: ctx,
        viewport: viewport
      };
      var renderTask = page.render(renderContext);

      // Wait for rendering to finish
      renderTask.promise.then(function() {
        pageRendering = false;
        if (pageNumPending !== null) {
          // New page rendering is pending
          renderPage(pageNumPending);
          pageNumPending = null;
        }
      annotate(pageNum);
      if (!jsonloaded) {
        loadJson(jsonfile);
      }
      
      });
    });

    // Update page counters
    document.getElementById('page_num').textContent = num;
  }

  /**
   * If another page rendering in progress, waits until the rendering is
   * finised. Otherwise, executes rendering immediately.
   */
  function queueRenderPage(num) {
    if (pageRendering) {
      pageNumPending = num;
    } else {
      renderPage(num);
    }
  }

  /**
   * Displays previous page.
   */
  function onPrevPage() {
    if (pageNum <= 1) {
      return;
    }
    pageNum--;
    selectedShapeIndex=false;
    queueRenderPage(pageNum);
  }
  document.getElementById('prev').addEventListener('click', onPrevPage);

  /**
   * Displays next page.
   */
  function onNextPage() {
    if (pageNum >= pdfDoc.numPages) {
      return;
    }
    pageNum++;
    selectedShapeIndex=false;
    queueRenderPage(pageNum);
  }
  document.getElementById('next').addEventListener('click', onNextPage);

  function loadJson(url) {
    // get shapes from Google Vision generated json
    fetch(url)
    .then(response => response.json())
    .then(response => { 
        for (var i=0; i<response.responses.length; i++) {
          shapes[i] = [];
          var blocks = response.responses[i].fullTextAnnotation.pages[0].blocks;
          var marge = 5;
          for (var j=0; j < blocks.length; j++) {
                var coords = blocks[j].boundingBox.normalizedVertices;
                // convert normalizedVertices to regular coords
                coords = coords.map(function(element) { return [element.x * overlay.width, 
                                                                element.y * overlay.height] });
                x = coords[0][0] - marge;
                y = coords[0][1] - marge;
                dx = coords[2][0] - coords[0][0] + marge*2;
                dy = coords[2][1] - coords[0][1] + marge*2;
                shapes[i].push({x, y, dx , dy, color});
          }
        }
    });
    jsonloaded=true;
  }


  
  function annotate(num) {
    // Annotator
    // https://riptutorial.com/html5-canvas/example/18918/dragging-circles---rectangles-around-the-canvas

    refreshOverlay = setInterval(drawAll, 500);
    overlay.width = canvas.width;
    overlay.height = canvas.height;
    // used to calc canvas position relative to window
    function reOffset() {
      var BB = overlay.getBoundingClientRect();
      offsetX = BB.left;
      offsetY = BB.top;        
    };
    reOffset();
    window.onscroll = function(e){ reOffset(); }
    window.onresize = function(e){ reOffset(); }
    canvas.onresize = function(e){ reOffset(); }

    // clear the canvas and 
    // redraw all shapes in their current positions every 10ms
    function drawAll() {
      overlayctx.clearRect(0, 0, overlay.width, overlay.height)
      for (var i=0; i<shapes[pageNum-1].length; i++) {
        shape = shapes[pageNum-1][i];
        overlayctx.lineWidth = 1;
        overlayctx.strokeStyle = shape.color;
        if(i == selectedShapeIndex) { 
          overlayctx.lineWidth = 2;
         }
        overlayctx.strokeRect(shape.x, shape.y, shape.dx, shape.dy);
        }
    };

    overlay.addEventListener('mousedown', e => {
      selectedShapeIndex = false
      overlayctx.strokeStyle = 'black';
      clearInterval(refreshOverlay)
      isDragging = true
      // calculate the current mouse position
      x = parseInt(e.clientX - offsetX);
      y = parseInt(e.clientY - offsetY);
      // if mouse is in a shape, select it
      for (var i=0; i<shapes[pageNum-1].length; i++) {
        shape = shapes[pageNum-1][i]
        if(x>shape.x && x<shape.x+shape.dx && y>shape.y && y<shape.y+shape.dy) {
          selectedShapeIndex = i;
        }
      }
    });

    overlay.addEventListener('mousemove', e => {
      // return if we're not dragging
      if(!isDragging){return}
      newX = parseInt(e.clientX - offsetX);
      newY = parseInt(e.clientY - offsetY);
      if(Number.isInteger(selectedShapeIndex)) {
        // redraw selected rectangle
        drawAll();
        shape = shapes[pageNum-1][selectedShapeIndex];
        shape.x = newX;
        shape.y = newY;

        
      } else {
          // draw a new rectangle
          drawAll();
          overlayctx.strokeRect(x, y, newX - x, newY - y);
      }
      
    });
        
    overlay.addEventListener('mouseup', e => {
      // the drag is over -- clear the isDragging flag
      isDragging = false
      refreshOverlay = setInterval(drawAll, 100)
      // how far has the mouse dragged from its previous mousemove position?
      newX = parseInt(e.clientX - offsetX);
      newY = parseInt(e.clientY - offsetY);
      dx = newX - x;
      dy = newY - y;
      if (dx == 0 || dy == 0) {return};

      if(Number.isInteger(selectedShapeIndex)) {
        // move rectangle
        shape = shapes[pageNum-1][selectedShapeIndex];
        shape.x = newX;
        shape.y = newY;
        }
      else 
      {
        // draw new rectangle
        length = shapes[pageNum-1].push({x, y, dx, dy});
        selectedShapeIndex = shapes[pageNum-1].length-1;
        shape = shapes[pageNum-1][selectedShapeIndex];
        /*
        // remove all rectangles inside selections
        var toremove = [];
        for (var i=0; i<shapes[pageNum-1].length; i++) {
          inShape = shapes[pageNum-1][i]
          if(inShape.x>shape.x && inShape.x+inShape.dx<shape.x+shape.dx && 
             inShape.y>shape.y && inShape.y+inShape.dy<shape.y+shape.dy) {
            toremove.splice(1, 0, i)
          }
        }
        console.log(toremove)
        for (i in toremove) {
          shapes[pageNum-1].splice(i, 1);
        }*/
      }
    });

    overlay.addEventListener('mouseout', e => {
      // return if we're not dragging
      if(!isDragging){return}
      // the drag is over -- clear the isDragging flag
      isDragging = false
    });

    document.addEventListener('keydown', e => {
      e.preventDefault();
      if (["Backspace", "Delete", "x"].includes(e.key)) {
        shapes[pageNum-1].splice(selectedShapeIndex, 1);
      }
    });
  }

  function changeColor(e) {
        // change color of selected shape
        shape = shapes[pageNum-1][selectedShapeIndex];
        shape.color = e.target.style['background-color']

        // if we have shape of the exact same size and position
        // in other pages, change their color too
        var limit = 10;
        for (var i=pageNum-1; i<shapes.length; i++) {
          for (var j=0; j<shapes[i].length; j++) {
            nextshape = shapes[i][j];
            if (Math.abs(nextshape.x - shape.x) < limit && 
                Math.abs(nextshape.y - shape.y) < limit &&
                Math.abs(nextshape.dx - shape.dx) < limit && 
                Math.abs(nextshape.dy - shape.dy) < limit) {
              nextshape.color = shape.color;
            }
          }
        }
  }

  var items = document.getElementsByClassName("annotator");
    for (var i = 0; i < items.length; i++) {
    items[i].addEventListener("click", changeColor);
  }


  /**
   * Asynchronously downloads PDF.
   */
  pdfjsLib.getDocument(url).promise.then(function(pdfDoc_) {
    pdfDoc = pdfDoc_
    document.getElementById('page_count').textContent = pdfDoc.numPages
    // Initial/first page rendering
    renderPage(pageNum);
  });


</script>

</body>
</html>
